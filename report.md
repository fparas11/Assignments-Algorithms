### **1. Εισαγωγή & Στόχος Εργασίας**

Η παρούσα αναφορά περιγράφει τον σχεδιασμό και την ανάλυση ενός αλγορίθμου για την ομαδοποίηση κόμβων (graph clustering) σε ένα δεδομένο μη κατευθυνόμενο και χωρίς βάρη γράφημα. Ο στόχος είναι ο αναδρομικός διαμερισμός του γράφου σε μικρότερες, συνεκτικές κοινότητες, βασιζόμενος στην αρχή της ελάχιστης τομής (minimum cut).

Τα datasets που μας δώθηκαν είναι τελείώς διαφορετικά μεταξύ τους, συνεπώς η υλοποίηση χρειαστηκε να ακολουθήσει μια **υβριδική προσέγγιση**, εφαρμόζοντας διαφορετικό αλγόριθμο για κάθε dataset.

---

### **2. Στρατηγική & Αλγόριθμοι**

1.  **`karateclub.txt` (Μικρό Κοινωνικό Δίκτυο):**
    *   **Αλγόριθμος:** **Προσαρμοσμένη Μέθοδος Αναδρομικού Διαμερισμού (s-t Min-Cut) βασισμένος στον Edmonds-Karp**.
    *   **Λογική:** Υλοποιεί την κεντρική ιδέα της εργασίας, διαιρώντας αναδρομικά το γράφημα. Το source (`s`) και sink (`t`) επιλέγονται ευριστικά χρησιμοποιόντας Breadth-First Search (με πολυπλοκότητα `O(|V|+|E|)`) για να προσεγγίσουν τη διάμετρο του γράφου, και η τομή υπολογίζεται με τον αλγόριθμο **Edmonds-Karp**.
    *   **Πολυπλοκότητα:** `O(D * |V|*|E|²)` όπου `D` το βάθος της αναδρομής.

2.  **`powergrid.txt` (Μεγάλος, Αραιός Γράφος):**
    *   **Αλγόριθμος:** **Girvan-Newman**.
    *   **Λογική:** Ο αλγόριθμος Girvan-Newman είναι ιδανικός για το πολύπλοκο δίκτυο ηλεκτρικής ενέργειας, επειδή αποκαλύπτει τη φυσική, ιεραρχική του δομή. Εντοπίζει τις κοινότητες αφαιρώντας στρατηγικά τις ακμές-«γέφυρες» που τις συνδέουν. Είναι είναι μια πιο στιβαρή και γενική μέθοδος απο την **Edmonds-Karp** η οποία συνεχίζει να ταιριάζει με την αναδρομική φύση του αλγορίθμου που ζητείται.
    *   **Πολυπλοκότητα:** `O(|V||E|²)`. Αν και οι τύποι της πολυπλοκότητάς τους, O(|V|*|E|²), φαίνονται ίδιοι, το νόημά τους διαφέρει. Για τον Girvan-Newman, ο τύπος αυτός περιγράφει ολόκληρη την, εξαιρετικά αργή, διαδικασία εντοπισμού κοινοτήτων. Αντίθετα, για τον Edmonds-Karp, περιγράφει απλώς το κόστος μίας και μόνο, μεμονωμένης ελάχιστης τομής.
    *   **Πρακτικός Περιορισμός:** Λόγω της υψηλής πολυπλοκότητας (`O(|E|^2|V|)`), η εκτέλεση περιορίζεται στα πρώτα **8 επίπεδα** της ιεραρχίας.

3.  **`erdos.txt` (Πολύ Μεγάλος Γράφος):**
    *   **Αλγόριθμος:** **Αναδρομική Φασματική Ομαδοποίηση (Recursive Spectral Clustering)**.
    *   **Λογική:** Ο γράφος είναι επισης αραιός και ακόμα μεγαλύτερος, σε βαθμό όπου το μέγεθος του να αποτρέπει την εφαρμογή του Girvan-Newman η οποιονδήποτε άλλο αναδρομικό αλγόριθμο. Αντί για αυτόν χρησιμοπούμε το Recursive Spectral Clustering, έναν ς διαιρετικό αλγόριθμο που χρησιμοποιεί το **Fiedler vector** του πίνακα **Laplacian** του γράφου για να βρει τη βέλτιστη τομή σε κάθε βήμα. 
    *   **Πολυπλοκότητα:** `O(D * |V|^2)`, όπου `D` το βάθος της αναδρομής. Ο υπολογισμός των ιδιοδιανυσμάτων (eigenvectors) είναι το υπολογιστικό bottleneck σε κάθε βήμα.

---

### **3. Ψευδοκώδικας Υλοποιημένων Αλγορίθμων**

#### **Κύρια Λογική (main.py)**
```
ΣΥΝΑΡΤΗΣΗ main():
  datasets = ['karate', 'powergrid', 'erdos']
  ΓΙΑ ΚΑΘΕ dataset ΣΕ datasets:
    // Βήμα 1: Φόρτωση του κατάλληλου γράφου και της συνάρτησης ομαδοποίησης
    ΑΝ dataset == 'karate':
      G = Φόρτωσε_Γράφο_Karate()
      cluster_func = karate.cluster
    ΑΝ dataset == 'powergrid':
      G = Φόρτωσε_Γράφο_Powergrid()
      cluster_func = powergrid.cluster
    ΑΝ dataset == 'erdos':
      G = Φόρτωσε_Γράφο_Erdos()
      cluster_func = erdos.cluster

    // Βήμα 2: Εκτέλεση της ομαδοποίησης
    αποτελέσματα = cluster_func(G)

    // Βήμα 3: Ανάθεση αποτελεσμάτων και δημιουργία γραφημάτων
    ΑΝ dataset == 'karate':
      // Το karate.cluster επιστρέφει και linkage_matrix για το δενδρόγραμμα
      (final_clusters, history, linkage_matrix) = αποτελέσματα
    ΑΛΛΙΩΣ:
      // Τα άλλα δύο επιστρέφουν μόνο clusters και history
      (final_clusters, history) = αποτελέσματα
      linkage_matrix = None

    // Η συνάρτηση generate_plots χειρίζεται έξυπνα τι θα σχεδιάσει
    generate_plots(G, history, linkage_matrix, final_clusters, dataset)
```

#### **1. Karate Club: Αναδρομικός Διαμερισμός με s-t Min-Cut**
```
ΣΥΝΑΡΤΗΣΗ cluster(Γράφος G):
  // Βήμα Α: Εύρεση της μεγαλύτερης συνεκτικής συνιστώσας
  main_component = Βρες_Μεγαλύτερη_Συνιστώσα(G)
  
  // Βήμα Β: Αναδρομική ομαδοποίηση στη μεγαλύτερη συνιστώσα
  split_log = [] // Λίστα για την καταγραφή των διαμερισμών
  final_components = _recursive_cluster(main_component, split_log, level=0)

  // Βήμα Γ: Επεξεργασία αποτελεσμάτων για δημιουργία history και linkage matrix
  (history, linkage_matrix) = _process_results(final_components, split_log)
  ΕΠΙΣΤΡΕΨΕ (final_components, history, linkage_matrix)

ΣΥΝΑΡΤΗΣΗ _recursive_cluster(Component C, log, level):
  // Βάση Αναδρομής
  ΑΝ |C| < MIN_SIZE Η' το C είναι κλίκα:
    ΕΠΙΣΤΡΕΨΕ [C]

  // Αναδρομικό Βήμα
  (subgraph1, subgraph2) = _split_component(C)
  ΑΝ subgraph2 είναι None: // Αν ο διαμερισμός απέτυχε
    ΕΠΙΣΤΡΕΨΕ [C]

  Καταγραφή_στο_log(level, C, [subgraph1, subgraph2])
  
  clusters1 = _recursive_cluster(subgraph1, log, level + 1)
  clusters2 = _recursive_cluster(subgraph2, log, level + 1)
  ΕΠΙΣΤΡΕΨΕ clusters1 + clusters2

ΣΥΝΑΡΤΗΣΗ _split_component(Component C):
  // Ευριστική 2-BFS για προσέγγιση της διαμέτρου
  start_node = C.nodes[0]
  αποστάσεις_1 = BFS(C, start_node)
  u = ο κόμβος με τη μέγιστη απόσταση στο αποστάσεις_1

  αποστάσεις_2 = BFS(C, u)
  v = ο κόμβος με τη μέγιστη απόσταση στο αποστάσεις_2
  s, t = u, v

  // Υπολογισμός ελάχιστης τομής
  (τιμή_τομής, (partition1, partition2)) = Edmonds_Karp_Min_Cut(C, s, t)
  ΕΠΙΣΤΡΕΨΕ (Γράφημα από partition1, Γράφημα από partition2)
```

#### **2. Power Grid: Αλγόριθμος Girvan-Newman**
```
ΣΥΝΑΡΤΗΣΗ cluster(Γράφος G):
  // Βήμα Α: Εύρεση της μεγαλύτερης συνεκτικής συνιστώσας
  main_component = Βρες_Μεγαλύτερη_Συνιστώσα(G)

  // Βήμα Β: Χρήση του iterator του Girvan-Newman από τη βιβλιοθήκη NetworkX
  gn_iterator = Girvan_newman(main_component)
  MAX_LEVELS = 8 
  
  partitions = []
  history = []
  ΓΙΑ i ΑΠΟ 0 ΕΩΣ MAX_LEVELS - 1:
    partition = next(gn_iterator) // Πάρε την επόμενη διαμέριση από τον iterator
    partitions.append(partition)
    Καταγραφή_του_history(level=i, partition)

  // Βήμα Γ: Επιστροφή της τελευταίας διαμέρισης και του ιστορικού
  final_clusters = partitions[-1]
  ΕΠΙΣΤΡΕΨΕ (final_clusters, history)
```

#### **3. Erdos: Αναδρομική Φασματική Ομαδοποίηση**
```
// Η λογική είναι παρόμοια με του Karate Club, αλλά αλλάζει η μέθοδος διαμερισμού
ΣΥΝΑΡΤΗΣΗ cluster(Γράφος G):
  main_component = Βρες_Μεγαλύτερη_Συνιστώσα(G)
  split_log = []
  final_components = _recursive_cluster(main_component, split_log, level=0)
  history = _process_history(final_components, split_log)
  ΕΠΙΣΤΡΕΨΕ (final_components, history)

ΣΥΝΑΡΤΗΣΗ _recursive_cluster(Component C, log, level):
  // Βάση Αναδρομής (ίδια με Karate)
  ΑΝ |C| < MIN_SIZE Η' το C είναι κλίκα: ΕΠΙΣΤΡΕΨΕ [C]
  
  // Αναδρομικό Βήμα
  (subgraph1, subgraph2) = _spectral_split(C) // Η κρίσιμη διαφορά είναι εδώ
  // ... (η υπόλοιπη συνάρτηση είναι ίδια με του Karate Club)

ΣΥΝΑΡΤΗΣΗ _spectral_split(Component C):
  // Βήμα 1: Υπολόγισε τον πίνακα Laplacian του C
  L = Normalized_Laplacian(C)

  // Βήμα 2: Βρες τον ιδιοδιανυσματιστή που αντιστοιχεί στη 2η μικρότερη ιδιοτιμή (Fiedler vector).
  fiedler_vector = Calculate_Fiedler_Vector(L)
  
  // Βήμα 3: Διαμέρισε τους κόμβους με βάση το πρόσημο των στοιχείων του Fiedler vector.
  Partition_1 = κόμβοι u όπου fiedler_vector[u] >= 0
  Partition_2 = κόμβοι u όπου fiedler_vector[u] < 0
  
  ΕΠΙΣΤΡΕΨΕ (Γράφημα από Partition_1, Γράφημα από Partition_2)
```

---

### **3.1. Ψευδοκώδικας Βοηθητικών Συναρτήσεων**

Παρακάτω περιγράφονται οι βασικές βοηθητικές συναρτήσεις που χρησιμοποιούνται από τους κύριους αλγορίθμους.

#### **Girvan_newman**
```
ΣΥΝΑΡΤΗΣΗ community.girvan_newman(Γράφος G):
  // Δημιουργείται ένας iterator που σε κάθε βήμα αφαιρεί την πιο "κεντρική" ακμή.
  Υπογράφημα_C = αντίγραφο του G
  ΟΣΟ το Υπογράφημα_C έχει ακμές:
    // Βήμα 1: Υπολόγισε την "betweenness centrality" για όλες τις ακμές
    centrality = Calculate_Edge_Betweenness(Υπογράφημα_C)

    // Βήμα 2: Βρες την ακμή(ές) με την υψηλότερη τιμή centrality
    max_centrality = μέγιστη τιμή στο `centrality`
    ακμές_προς_αφαίρεση = λίστα των ακμών με τιμή `max_centrality`

    // Βήμα 3: Παράγει (yield) τις τρέχουσες συνεκτικές συνιστώσες
    YIELD οι συνεκτικές συνιστώσες του `Υπογράφημα_C`

    // Βήμα 4: Αφαίρεσε τις ακμές που βρέθηκαν
    Αφαίρεσε τις `ακμές_προς_αφαίρεση` από το `Υπογράφημα_C`
```

#### **Βρες_Μεγαλύτερη_Συνιστώσα**
```
ΣΥΝΑΡΤΗΣΗ Βρες_Μεγαλύτερη_Συνιστώσα(Γράφος G):
  επισκεφθέντες_κόμβοι = κενό σύνολο
  συνιστώσες = κενή λίστα

  ΓΙΑ ΚΑΘΕ κόμβο `u` ΣΤΟΝ G:
    ΑΝ ο `u` ΔΕΝ ΕΙΝΑΙ ΣΤΟΥΣ `επισκεφθέντες_κόμβοι`:
      // Βρέθηκε νέα συνιστώσα, ξεκίνα BFS για να την βρεις ολόκληρη
      νέα_συνιστώσα = κενό σύνολο
      ουρά = νέα ουρά; Πρόσθεσε τον `u` στην `ουρά` και στους `επισκεφθέντες_κόμβοι`

      ΟΣΟ η `ουρά` ΔΕΝ ΕΙΝΑΙ κενή:
        τρέχων_κόμβος = αφαίρεσε από την `ουρά`
        Πρόσθεσε τον `τρέχων_κόμβο` στη `νέα_συνιστώσα`
        ΓΙΑ ΚΑΘΕ γείτονα `v` ΤΟΥ `τρέχων_κόμβος`:
          ΑΝ ο `v` ΔΕΝ ΕΙΝΑΙ ΣΤΟΥΣ `επισκεφθέντες_κόμβοι`:
            Πρόσθεσε τον `v` στην `ουρά` και στους `επισκεφθέντες_κόμβοι`
      
      Πρόσθεσε τη `νέα_συνιστώσα` στη λίστα `συνιστώσες`

  μεγαλύτερη_συνιστώσα = η συνιστώσα με το μέγιστο πλήθος κόμβων στις `συνιστώσες`
  ΕΠΙΣΤΡΕΨΕ Γράφημα_από_κόμβους(μεγαλύτερη_συνιστώσα)
```

#### **Normalized_Laplacian**
```
ΣΥΝΑΡΤΗΣΗ Normalized_Laplacian(Γράφος G):
  // Βήμα 1: Πάρε τον πίνακα γειτνίασης (Adjacency Matrix) A
  A = Adjacency_Matrix(G)

  // Βήμα 2: Δημιούργησε τον διαγώνιο πίνακα βαθμών (Degree Matrix) D
  D = ένας διαγώνιος πίνακας όπου D[i, i] = βαθμός του κόμβου i

  // Βήμα 3: Υπολόγισε τον αντίστροφο της τετραγωνικής ρίζας του D
  D_inv_sqrt = ένας διαγώνιος πίνακας όπου D_inv_sqrt[i, i] = 1 / sqrt(D[i, i])

  // Βήμα 4: Υπολόγισε τον κανονικοποιημένο πίνακα Laplacian (L_norm = I - D^(-1/2) * A * D^(-1/2))
  I = Πίνακας Ταυτότητας
  L_norm = I - (D_inv_sqrt * A * D_inv_sqrt)
  ΕΠΙΣΤΡΕΨΕ L_norm
```

#### **Calculate_Fiedler_Vector**
```
ΣΥΝΑΡΤΗΣΗ Calculate_Fiedler_Vector(Πίνακας L):
  // Βήμα 1: Υπολόγισε τις ιδιοτιμές και τα ιδιοδιανύσματα του L
  (ιδιοτιμές, ιδιοδιανύσματα) = Eigen_Decomposition(L)

  // Βήμα 2: Ταξινόμησε τις ιδιοτιμές και τα αντίστοιχα ιδιοδιανύσματα από τη μικρότερη στη μεγαλύτερη
  ταξινομημένα_ζεύγη = Ταξινόμησε(ιδιοτιμές, ιδιοδιανύσματα)

  // Βήμα 3: Το Fiedler vector είναι το ιδιοδιάνυσμα που αντιστοιχεί στη δεύτερη μικρότερη ιδιοτιμή
  fiedler_vector = το ιδιοδιάνυσμα από το δεύτερο ζεύγος στα `ταξινομημένα_ζεύγη`
  ΕΠΙΣΤΡΕΨΕ fiedler_vector
```

---

### **4. Απεικόνιση Αποτελεσμάτων**

Ανάλογα με το dataset και τον αλγόριθμο, χρησιμοποιούνται διαφορετικές τεχνικές απεικόνισης για να αναδειχθεί καλύτερα η δομή των κοινοτήτων και η συμπεριφορά του αλγορίθμου.

1.  **`karateclub.txt` (Αναδρομικός Διαμερισμός με Min-Cut):**
    *   **Δενδρόγραμμα:** Δημιουργείται ένα πλήρες δενδρόγραμμα που απεικονίζει ολόκληρη την ιεραρχική διαδικασία των διαμερισμών. Αυτό είναι εφικτό και χρήσιμο λόγω του μικρού μεγέθους του γράφου.
    *   **Γραφήματα Εξέλιξης:** Παράγονται γραφήματα που δείχνουν την εξέλιξη του πλήθους και του μεγέθους των κοινοτήτων, καθώς και του χρόνου εκτέλεσης, σε κάθε επίπεδο της αναδρομής.

2.  **`powergrid.txt` (Girvan-Newman):**
    *   **Γράφημα Κοινοτήτων:** Η δημιουργία ενός πλήρους δενδρογράμματος παραλείπεται λόγω του τεράστιου υπολογιστικού κόστους του αλγορίθμου Girvan-Newman. Αντί αυτού, ο αλγόριθμος εκτελείται για να βρει την μία, βέλτιστη διαμέριση (με βάση το modularity score) και το αποτέλεσμα απεικονίζεται ως ένας γράφος όπου οι κόμβοι είναι χρωματισμένοι ανάλογα με την τελική κοινότητα στην οποία ανήκουν.
    
3.  **`erdos.txt` (Αναδρομική Φασματική Ομαδοποίηση):**
    *   **Γράφημα Κοινοτήτων:** Παρόμοια με το powergrid, το δενδρόγραμμα παραλείπεται, αλλά για διαφορετικό λόγο: το πολύ μεγάλο μέγεθος του γράφου θα το καθιστούσε οπτικά αδιάβαστο. Η απεικόνιση γίνεται μέσω ενός γραφήματος κοινοτήτων που δείχνει την τελική ομαδοποίηση.
    *   **Γραφήματα Εξέλιξης:** Ο αλγόριθμος είναι αρκετά αποδοτικός για να παρακολουθείται η εξέλιξή του, επομένως παράγονται τα ίδια γραφήματα εξέλιξης με το karateclub, δείχνοντας τα στατιστικά σε κάθε αναδρομικό βήμα.

---

### **5. Δομές Δεδομένων**

Η υλοποίηση βασίζεται σε ένα συνδυασμό βασικών δομών δεδομένων της Python και εξειδικευμένων βιβλιοθηκών για την αποδοτική διαχείριση των γράφων και των αλγοριθμικών βημάτων.

*   **`networkx.Graph`**: Η κεντρική δομή για την αναπαράσταση όλων των γράφων. Παρέχει ένα πλούσιο και βελτιστοποιημένο API για λειτουργίες όπως η εύρεση γειτόνων, η δημιουργία υπογραφημάτων και ο υπολογισμός ιδιοτήτων του γράφου, απλοποιώντας σημαντικά την υλοποίηση. Βασίζεται στη Λίστα Γειτνίασης (Adjacency List) και η συγκεκριμένη υλοποίηση στην Python γίνεται συνήθως με ένα "λεξικό από λεξικά" (dictionary of dictionaries).


*   **`list` (Λίστα)**: Η πιο θεμελιώδης δομή που χρησιμοποιείται εκτενώς για:
    *   Την αποθήκευση των τελικών κοινοτήτων (`final_clusters`).
    *   Την καταγραφή του ιστορικού των επιπέδων της αναδρομής (`history`).
    *   Την υλοποίηση της ουράς (queue) στον αλγόριθμο BFS, όπου ένας δείκτης (`head`) χρησιμοποιείται για την αποδοτική αφαίρεση στοιχείων.

*   **`dict` (Λεξικό)**: Χρησιμοποιείται για την αποθήκευση δομημένων πληροφοριών. Κάθε στοιχείο στη λίστα `history` είναι ένα λεξικό που αντιστοιχίζει ιδιότητες (π.χ., `'level'`, `'time'`) με τις τιμές τους, κάνοντας τον κώδικα πιο ευανάγνωστο και επεκτάσιμο.

*   **`set` (Σύνολο)**: Επιλέγεται στρατηγικά για την αποθήκευση των κόμβων που έχουν ήδη επισκεφθεί (`visited_nodes`) κατά την εκτέλεση του BFS. Η ιδιότητά του για αναζήτηση και εισαγωγή σε σχεδόν σταθερό χρόνο (O(1)) το καθιστά ιδανικό για την αποφυγή διπλοεγγραφών και τον γρήγορο έλεγχο ύπαρξης ενός κόμβου.

*   **`numpy.ndarray`**: Απαραίτητο για τους αλγορίθμους που απαιτούν σύνθετους αριθμητικούς υπολογισμούς. Συγκεκριμένα, χρησιμοποιείται για:
    *   Τη `linkage_matrix` που παράγεται για το δενδρόγραμμα του Karate Club.
    *   Τη διαχείριση των ιδιοδιανυσμάτων (Fiedler vector) στη φασματική ομαδοποίηση του Erdos.
    *   Τον υπολογισμό μέσων όρων και άλλων στατιστικών στοιχείων στο ιστορικό.


